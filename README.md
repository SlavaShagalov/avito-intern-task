# Avito Intern Task

### Описание

- Используется разделение на слои `delivery`, `usecase`, `repository` согласно чистой архитектуре.
- Реализованы `Middlewares` для: отслеживания паники, логирования, проверки админского доступа, проверки авторизации.
- Конфигурирование приложения с использованием `.yaml` файла.
- Сервис поднимается в `Docker` контейнерах: база данных, кэш и основное приложение.
- Контейнеры конфигурируются в  `docker-compose`.
- В качестве СУБД используется `PostgreSQL`.
- В качестве кэша используется `Redis`.
- Все методы имеют префикс `/api/v1`.
- Подключен `Github Actions` с джобами `lint`, `test` и `build`.

### Makefile

В корне репозитория есть Makefile с командами проекта.

#### Поднять бэкенд, БД, кэш.

```shell
make up
```

#### Остановить сервер

```shell
make stop
```

#### Удалить все контейнеры вместе с volumes (удалить данные БД)

```shell
make down
```

#### Посмотреть логи бэкенда

```shell
make logs
```

#### Посмотреть логи другого контейнера, <SERVICE_NAME> - имя сервиса из docker-compose файла

```shell
make logs service=<SERVICE_NAME>
```

#### Запустить интеграционное тестирование

```shell
make test-integration
```

### API

TODO

### Проблемы, с которыми столкнулся

#### Обеспечение уникальности баннеров по фиче и тегу.

В условии сказано:

3. Фича и тег однозначно определяют баннер.

Придумал три варианта реализации схемы БД для этого:

1. Полностью нормализованная схема с использованием CHECK, который бы вызывал функцию проверки
уникальности сочетания полей из разных таблиц.

2. Использование массива для хранения тегов баннера прямо в таблице баннеров. Тогда все равно 
нужно сделать какой-то CHECK, который проверяет уникальность между сочетаниями фичи и каждого 
тега из массива тегов для всех баннеров.

3. Денормализованная схема, в которой дублируется фича. Этот вариант **был выбран** в связи с легким 
созданием ограничения уникальности с помощью PRIMARY KEY (feature_id, tag_id).

#### Отдача кешированных ответов при неустановленном флаге use_last_revision.

Использовался алгоритм Lazy Cache, т.е. бэкенд пытается пойти 
в кэш, если промах, то идет в БД, при этом обновляя кэш.
В создании ключа используются tag_id, feature_id, is_admin поля.
Кэшируются не только успешный ответ, но и ошибки.
